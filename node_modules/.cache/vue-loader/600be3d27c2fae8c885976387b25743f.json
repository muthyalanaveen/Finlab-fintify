{"remainingRequest":"/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/src/components/atoms/OPlacesAutoComplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/src/components/atoms/OPlacesAutoComplete.vue","mtime":1649953715464},{"path":"/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/node_modules/cache-loader/dist/cjs.js","mtime":1649977086874},{"path":"/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/node_modules/babel-loader/lib/index.js","mtime":1649977089120},{"path":"/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/node_modules/cache-loader/dist/cjs.js","mtime":1649977086874},{"path":"/Users/naveenmuthyala/Documents/Projects/returns_portal_ui/returns_portal_ui/node_modules/vue-loader/lib/index.js","mtime":1649977089802}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBPVGV4dEZpZWxkIGZyb20gJ0AvY29tcG9uZW50cy9tb2xlY3VsZXMvT1RleHRGaWVsZC52dWUnCi8qIGdsb2JhbCBnb29nbGUgKi8KY29uc3QgQUREUkVTU19DT01QT05FTlRTID0gewogIHN1YnByZW1pc2U6ICdzaG9ydF9uYW1lJywKICBzdHJlZXRfbnVtYmVyOiAnc2hvcnRfbmFtZScsCiAgcm91dGU6ICdsb25nX25hbWUnLAogIGxvY2FsaXR5OiAnbG9uZ19uYW1lJywKICBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzE6ICdzaG9ydF9uYW1lJywKICBhZG1pbmlzdHJhdGl2ZV9hcmVhX2xldmVsXzI6ICdsb25nX25hbWUnLAogIGNvdW50cnk6ICdsb25nX25hbWUnLAogIHBvc3RhbF9jb2RlOiAnc2hvcnRfbmFtZScKfQpjb25zdCBDSVRJRVNfVFlQRSA9IFsnbG9jYWxpdHknLCAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8zJ10KY29uc3QgUkVHSU9OU19UWVBFID0gWwogICdsb2NhbGl0eScsCiAgJ3N1YmxvY2FsaXR5JywKICAncG9zdGFsX2NvZGUnLAogICdjb3VudHJ5JywKICAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8xJywKICAnYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8yJwpdCi8qCiAgICAgIEJ5IGRlZmF1bHQsIHdlJ3JlIG9ubHkgaW5jbHVkaW5nIGJhc2ljIHBsYWNlIGRhdGEgYmVjYXVzZSByZXF1ZXN0aW5nIHRoZXNlCiAgICAgIGZpZWxkcyBwbGFjZSBkYXRhIGlzIG5vdCBhZGRpdGlvbmFsbHkgY2hhcmdlZCBieSBHb29nbGUuIFBsZWFzZSByZWZlciB0bzoKICAgICAgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9iaWxsaW5nL3VuZGVyc3RhbmRpbmctY29zdC1vZi11c2UjYmFzaWMtZGF0YQogICAgKi8KY29uc3QgQkFTSUNfREFUQV9GSUVMRFMgPSBbCiAgJ2FkZHJlc3NfY29tcG9uZW50cycsCiAgJ2Fkcl9hZGRyZXNzJywKICAnYWx0X2lkJywKICAnZm9ybWF0dGVkX2FkZHJlc3MnLAogICdnZW9tZXRyeScsCiAgJ2ljb24nLAogICdpZCcsCiAgJ25hbWUnLAogICdidXNpbmVzc19zdGF0dXMnLAogICdwaG90bycsCiAgJ3BsYWNlX2lkJywKICAnc2NvcGUnLAogICd0eXBlJywKICAndXJsJywKICAndmljaW5pdHknCl0KZXhwb3J0IGRlZmF1bHQgewogIGNvbXBvbmVudHM6IHsgT1RleHRGaWVsZCB9LAogIG5hbWU6ICdWdWVHb29nbGVBdXRvY29tcGxldGUnLAogIHByb3BzOiB7CiAgICBpZDogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiB0cnVlCiAgICB9LAogICAgY2xhc3NuYW1lOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgcmVxdWlyZWQ6IGZhbHNlLAogICAgICBkZWZhdWx0OiAnJwogICAgfSwKICAgIHBsYWNlaG9sZGVyOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogJ1N0YXJ0IHR5cGluZycKICAgIH0sCiAgICBkaXNhYmxlZDogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIHR5cGVzOiB7CiAgICAgIHR5cGU6IFN0cmluZywKICAgICAgZGVmYXVsdDogJ2FkZHJlc3MnCiAgICB9LAogICAgZmllbGRzOiB7CiAgICAgIHR5cGU6IEFycmF5LAogICAgICBkZWZhdWx0OiBmdW5jdGlvbiAoKSB7CiAgICAgICAgcmV0dXJuIEJBU0lDX0RBVEFfRklFTERTCiAgICAgIH0KICAgIH0sCiAgICBjb3VudHJ5OiB7CiAgICAgIHR5cGU6IFtTdHJpbmcsIEFycmF5XSwKICAgICAgZGVmYXVsdDogbnVsbAogICAgfSwKICAgIGVuYWJsZUdlb2xvY2F0aW9uOiB7CiAgICAgIHR5cGU6IEJvb2xlYW4sCiAgICAgIGRlZmF1bHQ6IGZhbHNlCiAgICB9LAogICAgZ2VvbG9jYXRpb25PcHRpb25zOiB7CiAgICAgIHR5cGU6IE9iamVjdCwKICAgICAgZGVmYXVsdDogbnVsbAogICAgfQogIH0sCiAgZGF0YSAoKSB7CiAgICByZXR1cm4gewogICAgICAvKioKICAgICAgICogVGhlIEF1dG9jb21wbGV0ZSBvYmplY3QuCiAgICAgICAqCiAgICAgICAqIEB0eXBlIHtBdXRvY29tcGxldGV9CiAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNBdXRvY29tcGxldGUKICAgICAgICovCiAgICAgIGF1dG9jb21wbGV0ZTogbnVsbCwKICAgICAgLyoqCiAgICAgICAqIEF1dG9jb21wbGV0ZSBpbnB1dCB0ZXh0CiAgICAgICAqIEB0eXBlIHtTdHJpbmd9CiAgICAgICAqLwogICAgICBhdXRvY29tcGxldGVUZXh0OiAnJywKICAgICAgZ2VvbG9jYXRpb246IHsKICAgICAgICAvKioKICAgICAgICAgKiBHb29nbGUgR2VvY29kZXIgT2JqZXQKICAgICAgICAgKiBAdHlwZSB7R2VvY29kZXJ9CiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0dlb2NvZGVyCiAgICAgICAgICovCiAgICAgICAgZ2VvY29kZXI6IG51bGwsCiAgICAgICAgLyoqCiAgICAgICAgICogRmlsbGVkIGFmdGVyIGdlb2xvY2F0ZSByZXN1bHQKICAgICAgICAgKiBAdHlwZSB7Q29vcmRpbmF0ZXN9CiAgICAgICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0Nvb3JkaW5hdGVzCiAgICAgICAgICovCiAgICAgICAgbG9jOiBudWxsLAogICAgICAgIC8qKgogICAgICAgICAqIEZpbGxlZCBhZnRlciBnZW9sb2NhdGUgcmVzdWx0CiAgICAgICAgICogQHR5cGUge1Bvc2l0aW9ufQogICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Qb3NpdGlvbgogICAgICAgICAqLwogICAgICAgIHBvc2l0aW9uOiBudWxsCiAgICAgIH0KICAgIH0KICB9LAogIHdhdGNoOiB7CiAgICBhdXRvY29tcGxldGVUZXh0OiBmdW5jdGlvbiAobmV3VmFsLCBvbGRWYWwpIHsKICAgICAgdGhpcy4kZW1pdCgnaW5wdXRDaGFuZ2UnLCB7IG5ld1ZhbCwgb2xkVmFsIH0sIHRoaXMuaWQpCiAgICB9LAogICAgY291bnRyeTogZnVuY3Rpb24gKG5ld1ZhbCwgb2xkVmFsKSB7CiAgICAgIHRoaXMuYXV0b2NvbXBsZXRlLnNldENvbXBvbmVudFJlc3RyaWN0aW9ucyh7CiAgICAgICAgY291bnRyeTogdGhpcy5jb3VudHJ5ID09PSBudWxsID8gW10gOiB0aGlzLmNvdW50cnkKICAgICAgfSkKICAgIH0KICB9LAogIG1vdW50ZWQ6IGZ1bmN0aW9uICgpIHsKICAgIGNvbnN0IG9wdGlvbnMgPSB7fQogICAgaWYgKHRoaXMudHlwZXMpIHsKICAgICAgb3B0aW9ucy50eXBlcyA9IFt0aGlzLnR5cGVzXQogICAgfQogICAgaWYgKHRoaXMuY291bnRyeSkgewogICAgICBvcHRpb25zLmNvbXBvbmVudFJlc3RyaWN0aW9ucyA9IHsKICAgICAgICBjb3VudHJ5OiB0aGlzLmNvdW50cnkKICAgICAgfQogICAgfQogICAgdGhpcy5hdXRvY29tcGxldGUgPSBuZXcgZ29vZ2xlLm1hcHMucGxhY2VzLkF1dG9jb21wbGV0ZSgKICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCksCiAgICAgIG9wdGlvbnMKICAgICkKICAgIHRoaXMuYXV0b2NvbXBsZXRlLnNldEZpZWxkcyh0aGlzLmZpZWxkcykKICAgIHRoaXMuYXV0b2NvbXBsZXRlLmFkZExpc3RlbmVyKCdwbGFjZV9jaGFuZ2VkJywgdGhpcy5vblBsYWNlQ2hhbmdlZCkKICB9LAogIG1ldGhvZHM6IHsKICAgIC8qKgogICAgICogV2hlbiBhIHBsYWNlIGNoYW5nZWQKICAgICAqLwogICAgb25QbGFjZUNoYW5nZWQgKCkgewogICAgICBjb25zdCBwbGFjZSA9IHRoaXMuYXV0b2NvbXBsZXRlLmdldFBsYWNlKCkKICAgICAgaWYgKCFwbGFjZS5nZW9tZXRyeSkgewogICAgICAgIC8vIFVzZXIgZW50ZXJlZCB0aGUgbmFtZSBvZiBhIFBsYWNlIHRoYXQgd2FzIG5vdCBzdWdnZXN0ZWQgYW5kCiAgICAgICAgLy8gcHJlc3NlZCB0aGUgRW50ZXIga2V5LCBvciB0aGUgUGxhY2UgRGV0YWlscyByZXF1ZXN0IGZhaWxlZC4KICAgICAgICB0aGlzLiRlbWl0KCduby1yZXN1bHRzLWZvdW5kJywgcGxhY2UsIHRoaXMuaWQpCiAgICAgICAgcmV0dXJuCiAgICAgIH0KICAgICAgaWYgKHBsYWNlLmFkZHJlc3NfY29tcG9uZW50cyAhPT0gdW5kZWZpbmVkKSB7CiAgICAgICAgLy8gcmV0dXJuIHJldHVybkRhdGEgb2JqZWN0IGFuZCBQbGFjZVJlc3VsdCBvYmplY3QKICAgICAgICB0aGlzLiRlbWl0KCdwbGFjZWNoYW5nZWQnLCB0aGlzLmZvcm1hdFJlc3VsdChwbGFjZSksIHBsYWNlLCB0aGlzLmlkKQogICAgICAgIC8vIHVwZGF0ZSBhdXRvY29tcGxldGVUZXh0IHRoZW4gZW1pdCBjaGFuZ2UgZXZlbnQKICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZVRleHQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS52YWx1ZQogICAgICAgIHRoaXMub25DaGFuZ2UoKQogICAgICB9CiAgICB9LAogICAgLyoqCiAgICAgKiBXaGVuIHRoZSBpbnB1dCBnZXRzIGZvY3VzCiAgICAgKi8KICAgIG9uRm9jdXMgKCkgewogICAgICB0aGlzLmJpYXNBdXRvY29tcGxldGVMb2NhdGlvbigpCiAgICAgIHRoaXMuJGVtaXQoJ2ZvY3VzJykKICAgIH0sCiAgICAvKioKICAgICAqIFdoZW4gdGhlIGlucHV0IGxvc2VzIGZvY3VzCiAgICAgKi8KICAgIG9uQmx1ciAoKSB7CiAgICAgIHRoaXMuJGVtaXQoJ2JsdXInKQogICAgfSwKICAgIC8qKgogICAgICogV2hlbiB0aGUgaW5wdXQgZ290IGNoYW5nZWQKICAgICAqLwogICAgb25DaGFuZ2UgKCkgewogICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0aGlzLmlkKS52YWx1ZSkKICAgIH0sCiAgICAvKioKICAgICAqIFdoZW4gYSBrZXkgZ2V0cyBwcmVzc2VkCiAgICAgKiBAcGFyYW0gIHtFdmVudH0gZXZlbnQgQSBrZXlwcmVzcyBldmVudAogICAgICovCiAgICBvbktleVByZXNzIChldmVudCkgewogICAgICB0aGlzLiRlbWl0KCdrZXlwcmVzcycsIGV2ZW50KQogICAgfSwKICAgIC8qKgogICAgICogV2hlbiBhIGtleXVwIG9jY3VycwogICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IEEga2V5dXAgZXZlbnQKICAgICAqLwogICAgb25LZXlVcCAoZXZlbnQpIHsKICAgICAgdGhpcy4kZW1pdCgna2V5dXAnLCBldmVudCkKICAgIH0sCiAgICAvKioKICAgICAqIENsZWFyIHRoZSBpbnB1dAogICAgICovCiAgICBjbGVhciAoKSB7CiAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCA9ICcnCiAgICB9LAogICAgLyoqCiAgICAgKiBGb2N1cyB0aGUgaW5wdXQKICAgICAqLwogICAgZm9jdXMgKCkgewogICAgICB0aGlzLiRyZWZzLmF1dG9jb21wbGV0ZS5mb2N1cygpCiAgICB9LAogICAgLyoqCiAgICAgKiBCbHVyIHRoZSBpbnB1dAogICAgICovCiAgICBibHVyICgpIHsKICAgICAgdGhpcy4kcmVmcy5hdXRvY29tcGxldGUuYmx1cigpCiAgICB9LAogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBpbnB1dAogICAgICogQHBhcmFtICB7U3RyaW5nfSB2YWx1ZQogICAgICovCiAgICB1cGRhdGUgKHZhbHVlKSB7CiAgICAgIHRoaXMuYXV0b2NvbXBsZXRlVGV4dCA9IHZhbHVlCiAgICB9LAogICAgLyoqCiAgICAgKiBVcGRhdGUgdGhlIGNvb3JkaW5hdGVzIG9mIHRoZSBpbnB1dAogICAgICogQHBhcmFtICB7Q29vcmRpbmF0ZXN9IHZhbHVlCiAgICAgKi8KICAgIHVwZGF0ZUNvb3JkaW5hdGVzICh2YWx1ZSkgewogICAgICBpZiAoIXZhbHVlICYmICEodmFsdWUubGF0IHx8IHZhbHVlLmxuZykpIHJldHVybgogICAgICBpZiAoIXRoaXMuZ2VvbG9jYXRpb24uZ2VvY29kZXIpIHsKICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyID0gbmV3IGdvb2dsZS5tYXBzLkdlb2NvZGVyKCkKICAgICAgfQogICAgICB0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyLmdlb2NvZGUoCiAgICAgICAgeyBsb2NhdGlvbjogdmFsdWUgfSwKICAgICAgICAocmVzdWx0cywgc3RhdHVzKSA9PiB7CiAgICAgICAgICBpZiAoc3RhdHVzID09PSAnT0snKSB7CiAgICAgICAgICAgIHJlc3VsdHMgPSB0aGlzLmZpbHRlckdlb2NvZGVSZXN1bHRUeXBlcyhyZXN1bHRzKQogICAgICAgICAgICBpZiAocmVzdWx0c1swXSkgewogICAgICAgICAgICAgIHRoaXMuJGVtaXQoCiAgICAgICAgICAgICAgICAncGxhY2VjaGFuZ2VkJywKICAgICAgICAgICAgICAgIHRoaXMuZm9ybWF0UmVzdWx0KHJlc3VsdHNbMF0pLAogICAgICAgICAgICAgICAgcmVzdWx0c1swXSwKICAgICAgICAgICAgICAgIHRoaXMuaWQKICAgICAgICAgICAgICApCiAgICAgICAgICAgICAgdGhpcy51cGRhdGUocmVzdWx0c1swXS5mb3JtYXR0ZWRfYWRkcmVzcykKICAgICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsICdubyByZXN1bHQgZm9yIHByb3ZpZGVkIGNvb3JkaW5hdGVzJykKICAgICAgICAgICAgfQogICAgICAgICAgfSBlbHNlIHsKICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCAnZXJyb3IgZ2V0dGluZyBhZGRyZXNzIGZyb20gY29vcmRzJykKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgICkKICAgIH0sCiAgICAvKioKICAgICAqIFVwZGF0ZSBsb2NhdGlvbiBiYXNlZCBvbiBuYXZpZ2F0b3IgZ2VvbG9jYXRpb24KICAgICAqLwogICAgZ2VvbG9jYXRlICgpIHsKICAgICAgdGhpcy51cGRhdGVHZW9sb2NhdGlvbigoZ2VvbG9jYXRpb24sIHBvc2l0aW9uKSA9PiB7CiAgICAgICAgdGhpcy51cGRhdGVDb29yZGluYXRlcyhnZW9sb2NhdGlvbikKICAgICAgfSkKICAgIH0sCiAgICAvKioKICAgICAqIFVwZGF0ZSBpbnRlcm5hbCBsb2NhdGlvbiBmcm9tIG5hdmlnYXRvciBnZW9sb2NhdGlvbgogICAgICogQHBhcmFtICB7RnVuY3Rpb259IChnZW9sb2NhdGlvbiwgcG9zaXRpb24pCiAgICAgKi8KICAgIHVwZGF0ZUdlb2xvY2F0aW9uIChjYWxsYmFjayA9IG51bGwpIHsKICAgICAgaWYgKG5hdmlnYXRvci5nZW9sb2NhdGlvbikgewogICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fQogICAgICAgIGlmICh0aGlzLmdlb2xvY2F0aW9uT3B0aW9ucykgewogICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCB0aGlzLmdlb2xvY2F0aW9uT3B0aW9ucykKICAgICAgICB9CiAgICAgICAgbmF2aWdhdG9yLmdlb2xvY2F0aW9uLmdldEN1cnJlbnRQb3NpdGlvbigKICAgICAgICAgIChwb3NpdGlvbikgPT4gewogICAgICAgICAgICBjb25zdCBnZW9sb2NhdGlvbiA9IHsKICAgICAgICAgICAgICBsYXQ6IHBvc2l0aW9uLmNvb3Jkcy5sYXRpdHVkZSwKICAgICAgICAgICAgICBsbmc6IHBvc2l0aW9uLmNvb3Jkcy5sb25naXR1ZGUKICAgICAgICAgICAgfQogICAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLmxvYyA9IGdlb2xvY2F0aW9uCiAgICAgICAgICAgIHRoaXMuZ2VvbG9jYXRpb24ucG9zaXRpb24gPSBwb3NpdGlvbgogICAgICAgICAgICBpZiAoY2FsbGJhY2spIGNhbGxiYWNrKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikKICAgICAgICAgIH0sCiAgICAgICAgICAoZXJyKSA9PiB7CiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgJ0Nhbm5vdCBnZXQgQ29vcmRpbmF0ZXMgZnJvbSBuYXZpZ2F0b3InLCBlcnIpCiAgICAgICAgICB9LAogICAgICAgICAgb3B0aW9ucwogICAgICAgICkKICAgICAgfQogICAgfSwKICAgIC8vIEJpYXMgdGhlIGF1dG9jb21wbGV0ZSBvYmplY3QgdG8gdGhlIHVzZXIncyBnZW9ncmFwaGljYWwgbG9jYXRpb24sCiAgICAvLyBhcyBzdXBwbGllZCBieSB0aGUgYnJvd3NlcidzICduYXZpZ2F0b3IuZ2VvbG9jYXRpb24nIG9iamVjdC4KICAgIGJpYXNBdXRvY29tcGxldGVMb2NhdGlvbiAoKSB7CiAgICAgIGlmICh0aGlzLmVuYWJsZUdlb2xvY2F0aW9uKSB7CiAgICAgICAgdGhpcy51cGRhdGVHZW9sb2NhdGlvbigoZ2VvbG9jYXRpb24sIHBvc2l0aW9uKSA9PiB7CiAgICAgICAgICBjb25zdCBjaXJjbGUgPSBuZXcgZ29vZ2xlLm1hcHMuQ2lyY2xlKHsKICAgICAgICAgICAgY2VudGVyOiBnZW9sb2NhdGlvbiwKICAgICAgICAgICAgcmFkaXVzOiBwb3NpdGlvbi5jb29yZHMuYWNjdXJhY3kKICAgICAgICAgIH0pCiAgICAgICAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRCb3VuZHMoY2lyY2xlLmdldEJvdW5kcygpKQogICAgICAgIH0pCiAgICAgIH0KICAgIH0sCiAgICAvKioKICAgICAqIEZvcm1hdCByZXN1bHQgZnJvbSBHZW8gZ29vZ2xlIEFQSXMKICAgICAqIEBwYXJhbSBwbGFjZQogICAgICogQHJldHVybnMge3tmb3JtYXR0ZWQgb3V0cHV0fX0KICAgICAqLwogICAgZm9ybWF0UmVzdWx0IChwbGFjZSkgewogICAgICBjb25zdCByZXR1cm5EYXRhID0ge30KICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHMubGVuZ3RoOyBpKyspIHsKICAgICAgICBjb25zdCBhZGRyZXNzVHlwZSA9IHBsYWNlLmFkZHJlc3NfY29tcG9uZW50c1tpXS50eXBlc1swXQogICAgICAgIGlmIChBRERSRVNTX0NPTVBPTkVOVFNbYWRkcmVzc1R5cGVdKSB7CiAgICAgICAgICBjb25zdCB2YWwgPQogICAgICAgICAgICBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbaV1bQUREUkVTU19DT01QT05FTlRTW2FkZHJlc3NUeXBlXV0KICAgICAgICAgIHJldHVybkRhdGFbYWRkcmVzc1R5cGVdID0gdmFsCiAgICAgICAgfQogICAgICB9CiAgICAgIHJldHVybkRhdGEubGF0aXR1ZGUgPSBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sYXQoKQogICAgICByZXR1cm5EYXRhLmxvbmdpdHVkZSA9IHBsYWNlLmdlb21ldHJ5LmxvY2F0aW9uLmxuZygpCiAgICAgIHJldHVybiByZXR1cm5EYXRhCiAgICB9LAogICAgLyoqCiAgICAgKiBFeHRyYWN0IGNvbmZpZ3VyZWQgdHlwZXMgb3V0IG9mIHJhdyByZXN1bHQgYXMKICAgICAqIEdlb2NvZGUgQVBJIGRvZXMgbm90IGFsbG93IHRvIGRvIGl0CiAgICAgKiBAcGFyYW0gcmVzdWx0cwogICAgICogQHJldHVybnMge0dlb2NvZGVyUmVzdWx0fQogICAgICogQGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vbWFwcy9kb2N1bWVudGF0aW9uL2phdmFzY3JpcHQvcmVmZXJlbmNlI0dlb2NvZGVyUmVzdWx0CiAgICAgKi8KICAgIGZpbHRlckdlb2NvZGVSZXN1bHRUeXBlcyAocmVzdWx0cykgewogICAgICBpZiAoIXJlc3VsdHMgfHwgIXRoaXMudHlwZXMpIHJldHVybiByZXN1bHRzCiAgICAgIGNvbnN0IG91dHB1dCA9IFtdCiAgICAgIGxldCB0eXBlcyA9IFt0aGlzLnR5cGVzXQogICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJyhjaXRpZXMpJykpIHR5cGVzID0gdHlwZXMuY29uY2F0KENJVElFU19UWVBFKQogICAgICBpZiAodHlwZXMuaW5jbHVkZXMoJyhyZWdpb25zKScpKSB0eXBlcyA9IHR5cGVzLmNvbmNhdChSRUdJT05TX1RZUEUpCiAgICAgIGZvciAoY29uc3QgciBvZiByZXN1bHRzKSB7CiAgICAgICAgZm9yIChjb25zdCB0IG9mIHIudHlwZXMpIHsKICAgICAgICAgIGlmICh0eXBlcy5pbmNsdWRlcyh0KSkgewogICAgICAgICAgICBvdXRwdXQucHVzaChyKQogICAgICAgICAgICBicmVhawogICAgICAgICAgfQogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm4gb3V0cHV0CiAgICB9CiAgfQp9Cg=="},{"version":3,"sources":["OPlacesAutoComplete.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"OPlacesAutoComplete.vue","sourceRoot":"src/components/atoms","sourcesContent":["// Code based on from https://github.com/olefirenko/vue-google-autocomplete\n\n<template>\n  <o-text-field\n    ref=\"autocomplete\"\n    type=\"text\"\n    :class=\"classname\"\n    :id=\"id\"\n    :placeholder=\"placeholder\"\n    :disabled=\"disabled\"\n    v-model=\"autocompleteText\"\n    @focus=\"onFocus()\"\n    @blur=\"onBlur()\"\n    @change=\"onChange\"\n    @keypress=\"onKeyPress\"\n    @keyup=\"onKeyUp\"\n    @onChange=\"onChange\"\n    v-bind=\"{...$props, ...$attrs}\"\n  />\n</template>\n\n<script>\nimport OTextField from '@/components/molecules/OTextField.vue'\n/* global google */\nconst ADDRESS_COMPONENTS = {\n  subpremise: 'short_name',\n  street_number: 'short_name',\n  route: 'long_name',\n  locality: 'long_name',\n  administrative_area_level_1: 'short_name',\n  administrative_area_level_2: 'long_name',\n  country: 'long_name',\n  postal_code: 'short_name'\n}\nconst CITIES_TYPE = ['locality', 'administrative_area_level_3']\nconst REGIONS_TYPE = [\n  'locality',\n  'sublocality',\n  'postal_code',\n  'country',\n  'administrative_area_level_1',\n  'administrative_area_level_2'\n]\n/*\n      By default, we're only including basic place data because requesting these\n      fields place data is not additionally charged by Google. Please refer to:\n      https://developers.google.com/maps/billing/understanding-cost-of-use#basic-data\n    */\nconst BASIC_DATA_FIELDS = [\n  'address_components',\n  'adr_address',\n  'alt_id',\n  'formatted_address',\n  'geometry',\n  'icon',\n  'id',\n  'name',\n  'business_status',\n  'photo',\n  'place_id',\n  'scope',\n  'type',\n  'url',\n  'vicinity'\n]\nexport default {\n  components: { OTextField },\n  name: 'VueGoogleAutocomplete',\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    classname: {\n      type: String,\n      required: false,\n      default: ''\n    },\n    placeholder: {\n      type: String,\n      default: 'Start typing'\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    types: {\n      type: String,\n      default: 'address'\n    },\n    fields: {\n      type: Array,\n      default: function () {\n        return BASIC_DATA_FIELDS\n      }\n    },\n    country: {\n      type: [String, Array],\n      default: null\n    },\n    enableGeolocation: {\n      type: Boolean,\n      default: false\n    },\n    geolocationOptions: {\n      type: Object,\n      default: null\n    }\n  },\n  data () {\n    return {\n      /**\n       * The Autocomplete object.\n       *\n       * @type {Autocomplete}\n       * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n       */\n      autocomplete: null,\n      /**\n       * Autocomplete input text\n       * @type {String}\n       */\n      autocompleteText: '',\n      geolocation: {\n        /**\n         * Google Geocoder Objet\n         * @type {Geocoder}\n         * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n         */\n        geocoder: null,\n        /**\n         * Filled after geolocate result\n         * @type {Coordinates}\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n         */\n        loc: null,\n        /**\n         * Filled after geolocate result\n         * @type {Position}\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n         */\n        position: null\n      }\n    }\n  },\n  watch: {\n    autocompleteText: function (newVal, oldVal) {\n      this.$emit('inputChange', { newVal, oldVal }, this.id)\n    },\n    country: function (newVal, oldVal) {\n      this.autocomplete.setComponentRestrictions({\n        country: this.country === null ? [] : this.country\n      })\n    }\n  },\n  mounted: function () {\n    const options = {}\n    if (this.types) {\n      options.types = [this.types]\n    }\n    if (this.country) {\n      options.componentRestrictions = {\n        country: this.country\n      }\n    }\n    this.autocomplete = new google.maps.places.Autocomplete(\n      document.getElementById(this.id),\n      options\n    )\n    this.autocomplete.setFields(this.fields)\n    this.autocomplete.addListener('place_changed', this.onPlaceChanged)\n  },\n  methods: {\n    /**\n     * When a place changed\n     */\n    onPlaceChanged () {\n      const place = this.autocomplete.getPlace()\n      if (!place.geometry) {\n        // User entered the name of a Place that was not suggested and\n        // pressed the Enter key, or the Place Details request failed.\n        this.$emit('no-results-found', place, this.id)\n        return\n      }\n      if (place.address_components !== undefined) {\n        // return returnData object and PlaceResult object\n        this.$emit('placechanged', this.formatResult(place), place, this.id)\n        // update autocompleteText then emit change event\n        this.autocompleteText = document.getElementById(this.id).value\n        this.onChange()\n      }\n    },\n    /**\n     * When the input gets focus\n     */\n    onFocus () {\n      this.biasAutocompleteLocation()\n      this.$emit('focus')\n    },\n    /**\n     * When the input loses focus\n     */\n    onBlur () {\n      this.$emit('blur')\n    },\n    /**\n     * When the input got changed\n     */\n    onChange () {\n      this.$emit('change', document.getElementById(this.id).value)\n    },\n    /**\n     * When a key gets pressed\n     * @param  {Event} event A keypress event\n     */\n    onKeyPress (event) {\n      this.$emit('keypress', event)\n    },\n    /**\n     * When a keyup occurs\n     * @param  {Event} event A keyup event\n     */\n    onKeyUp (event) {\n      this.$emit('keyup', event)\n    },\n    /**\n     * Clear the input\n     */\n    clear () {\n      this.autocompleteText = ''\n    },\n    /**\n     * Focus the input\n     */\n    focus () {\n      this.$refs.autocomplete.focus()\n    },\n    /**\n     * Blur the input\n     */\n    blur () {\n      this.$refs.autocomplete.blur()\n    },\n    /**\n     * Update the value of the input\n     * @param  {String} value\n     */\n    update (value) {\n      this.autocompleteText = value\n    },\n    /**\n     * Update the coordinates of the input\n     * @param  {Coordinates} value\n     */\n    updateCoordinates (value) {\n      if (!value && !(value.lat || value.lng)) return\n      if (!this.geolocation.geocoder) {\n        this.geolocation.geocoder = new google.maps.Geocoder()\n      }\n      this.geolocation.geocoder.geocode(\n        { location: value },\n        (results, status) => {\n          if (status === 'OK') {\n            results = this.filterGeocodeResultTypes(results)\n            if (results[0]) {\n              this.$emit(\n                'placechanged',\n                this.formatResult(results[0]),\n                results[0],\n                this.id\n              )\n              this.update(results[0].formatted_address)\n            } else {\n              this.$emit('error', 'no result for provided coordinates')\n            }\n          } else {\n            this.$emit('error', 'error getting address from coords')\n          }\n        }\n      )\n    },\n    /**\n     * Update location based on navigator geolocation\n     */\n    geolocate () {\n      this.updateGeolocation((geolocation, position) => {\n        this.updateCoordinates(geolocation)\n      })\n    },\n    /**\n     * Update internal location from navigator geolocation\n     * @param  {Function} (geolocation, position)\n     */\n    updateGeolocation (callback = null) {\n      if (navigator.geolocation) {\n        const options = {}\n        if (this.geolocationOptions) {\n          Object.assign(options, this.geolocationOptions)\n        }\n        navigator.geolocation.getCurrentPosition(\n          (position) => {\n            const geolocation = {\n              lat: position.coords.latitude,\n              lng: position.coords.longitude\n            }\n            this.geolocation.loc = geolocation\n            this.geolocation.position = position\n            if (callback) callback(geolocation, position)\n          },\n          (err) => {\n            this.$emit('error', 'Cannot get Coordinates from navigator', err)\n          },\n          options\n        )\n      }\n    },\n    // Bias the autocomplete object to the user's geographical location,\n    // as supplied by the browser's 'navigator.geolocation' object.\n    biasAutocompleteLocation () {\n      if (this.enableGeolocation) {\n        this.updateGeolocation((geolocation, position) => {\n          const circle = new google.maps.Circle({\n            center: geolocation,\n            radius: position.coords.accuracy\n          })\n          this.autocomplete.setBounds(circle.getBounds())\n        })\n      }\n    },\n    /**\n     * Format result from Geo google APIs\n     * @param place\n     * @returns {{formatted output}}\n     */\n    formatResult (place) {\n      const returnData = {}\n      for (let i = 0; i < place.address_components.length; i++) {\n        const addressType = place.address_components[i].types[0]\n        if (ADDRESS_COMPONENTS[addressType]) {\n          const val =\n            place.address_components[i][ADDRESS_COMPONENTS[addressType]]\n          returnData[addressType] = val\n        }\n      }\n      returnData.latitude = place.geometry.location.lat()\n      returnData.longitude = place.geometry.location.lng()\n      return returnData\n    },\n    /**\n     * Extract configured types out of raw result as\n     * Geocode API does not allow to do it\n     * @param results\n     * @returns {GeocoderResult}\n     * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n     */\n    filterGeocodeResultTypes (results) {\n      if (!results || !this.types) return results\n      const output = []\n      let types = [this.types]\n      if (types.includes('(cities)')) types = types.concat(CITIES_TYPE)\n      if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE)\n      for (const r of results) {\n        for (const t of r.types) {\n          if (types.includes(t)) {\n            output.push(r)\n            break\n          }\n        }\n      }\n      return output\n    }\n  }\n}\n</script>\n"]}]}