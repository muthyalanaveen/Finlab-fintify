{"remainingRequest":"/Users/naveenmuthyala/Documents/Projects/Asset/fintify/node_modules/vue-loader/lib/index.js??vue-loader-options!/Users/naveenmuthyala/Documents/Projects/Asset/fintify/src/components/atoms/OPlacesAutoComplete.vue?vue&type=script&lang=js&","dependencies":[{"path":"/Users/naveenmuthyala/Documents/Projects/Asset/fintify/src/components/atoms/OPlacesAutoComplete.vue","mtime":1653330817023},{"path":"/Users/naveenmuthyala/Documents/Projects/Asset/fintify/node_modules/cache-loader/dist/cjs.js","mtime":1649977086874},{"path":"/Users/naveenmuthyala/Documents/Projects/Asset/fintify/node_modules/babel-loader/lib/index.js","mtime":1649977089120},{"path":"/Users/naveenmuthyala/Documents/Projects/Asset/fintify/node_modules/cache-loader/dist/cjs.js","mtime":1649977086874},{"path":"/Users/naveenmuthyala/Documents/Projects/Asset/fintify/node_modules/vue-loader/lib/index.js","mtime":1649977089802}],"contextDependencies":[],"result":[{"type":"Buffer","data":"base64:Ly8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KLy8KCmltcG9ydCBPVGV4dEZpZWxkIGZyb20gJ0AvY29tcG9uZW50cy9tb2xlY3VsZXMvT1RleHRGaWVsZC52dWUnCmltcG9ydCB7IG1hcEdldHRlcnMgfSBmcm9tICd2dWV4JwovKiBnbG9iYWwgZ29vZ2xlICovCmNvbnN0IEFERFJFU1NfQ09NUE9ORU5UUyA9IHsKICBzdWJwcmVtaXNlOiAnc2hvcnRfbmFtZScsCiAgc3RyZWV0X251bWJlcjogJ3Nob3J0X25hbWUnLAogIHJvdXRlOiAnbG9uZ19uYW1lJywKICBsb2NhbGl0eTogJ2xvbmdfbmFtZScsCiAgYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8xOiAnc2hvcnRfbmFtZScsCiAgYWRtaW5pc3RyYXRpdmVfYXJlYV9sZXZlbF8yOiAnbG9uZ19uYW1lJywKICBjb3VudHJ5OiAnbG9uZ19uYW1lJywKICBwb3N0YWxfY29kZTogJ3Nob3J0X25hbWUnCn0KY29uc3QgQ0lUSUVTX1RZUEUgPSBbJ2xvY2FsaXR5JywgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMyddCmNvbnN0IFJFR0lPTlNfVFlQRSA9IFsKICAnbG9jYWxpdHknLAogICdzdWJsb2NhbGl0eScsCiAgJ3Bvc3RhbF9jb2RlJywKICAnY291bnRyeScsCiAgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMScsCiAgJ2FkbWluaXN0cmF0aXZlX2FyZWFfbGV2ZWxfMicKXQovKgogICAgICBCeSBkZWZhdWx0LCB3ZSdyZSBvbmx5IGluY2x1ZGluZyBiYXNpYyBwbGFjZSBkYXRhIGJlY2F1c2UgcmVxdWVzdGluZyB0aGVzZQogICAgICBmaWVsZHMgcGxhY2UgZGF0YSBpcyBub3QgYWRkaXRpb25hbGx5IGNoYXJnZWQgYnkgR29vZ2xlLiBQbGVhc2UgcmVmZXIgdG86CiAgICAgIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvYmlsbGluZy91bmRlcnN0YW5kaW5nLWNvc3Qtb2YtdXNlI2Jhc2ljLWRhdGEKICAgICovCmNvbnN0IEJBU0lDX0RBVEFfRklFTERTID0gWwogICdhZGRyZXNzX2NvbXBvbmVudHMnLAogICdhZHJfYWRkcmVzcycsCiAgJ2FsdF9pZCcsCiAgJ2Zvcm1hdHRlZF9hZGRyZXNzJywKICAnZ2VvbWV0cnknLAogICdpY29uJywKICAnaWQnLAogICduYW1lJywKICAnYnVzaW5lc3Nfc3RhdHVzJywKICAncGhvdG8nLAogICdwbGFjZV9pZCcsCiAgJ3Njb3BlJywKICAndHlwZScsCiAgJ3VybCcsCiAgJ3ZpY2luaXR5JwpdCmV4cG9ydCBkZWZhdWx0IHsKICBjb21wb25lbnRzOiB7IE9UZXh0RmllbGQgfSwKICBuYW1lOiAnVnVlR29vZ2xlQXV0b2NvbXBsZXRlJywKICBwcm9wczogewogICAgaWQ6IHsKICAgICAgdHlwZTogU3RyaW5nLAogICAgICByZXF1aXJlZDogdHJ1ZQogICAgfSwKICAgIGNsYXNzbmFtZTogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIHJlcXVpcmVkOiBmYWxzZSwKICAgICAgZGVmYXVsdDogJycKICAgIH0sCiAgICBwbGFjZWhvbGRlcjogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICdTdGFydCB0eXBpbmcnCiAgICB9LAogICAgZGlzYWJsZWQ6IHsKICAgICAgdHlwZTogQm9vbGVhbiwKICAgICAgZGVmYXVsdDogZmFsc2UKICAgIH0sCiAgICB0eXBlczogewogICAgICB0eXBlOiBTdHJpbmcsCiAgICAgIGRlZmF1bHQ6ICdhZGRyZXNzJwogICAgfSwKICAgIGZpZWxkczogewogICAgICB0eXBlOiBBcnJheSwKICAgICAgZGVmYXVsdDogZnVuY3Rpb24gKCkgewogICAgICAgIHJldHVybiBCQVNJQ19EQVRBX0ZJRUxEUwogICAgICB9CiAgICB9LAogICAgY291bnRyeTogewogICAgICB0eXBlOiBbU3RyaW5nLCBBcnJheV0sCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0sCiAgICBlbmFibGVHZW9sb2NhdGlvbjogewogICAgICB0eXBlOiBCb29sZWFuLAogICAgICBkZWZhdWx0OiBmYWxzZQogICAgfSwKICAgIGdlb2xvY2F0aW9uT3B0aW9uczogewogICAgICB0eXBlOiBPYmplY3QsCiAgICAgIGRlZmF1bHQ6IG51bGwKICAgIH0KICB9LAogIGRhdGEgKCkgewogICAgcmV0dXJuIHsKICAgICAgLyoqCiAgICAgICAqIFRoZSBBdXRvY29tcGxldGUgb2JqZWN0LgogICAgICAgKgogICAgICAgKiBAdHlwZSB7QXV0b2NvbXBsZXRlfQogICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9tYXBzL2RvY3VtZW50YXRpb24vamF2YXNjcmlwdC9yZWZlcmVuY2UjQXV0b2NvbXBsZXRlCiAgICAgICAqLwogICAgICBhdXRvY29tcGxldGU6IG51bGwsCiAgICAgIC8qKgogICAgICAgKiBBdXRvY29tcGxldGUgaW5wdXQgdGV4dAogICAgICAgKiBAdHlwZSB7U3RyaW5nfQogICAgICAgKi8KICAgICAgYXV0b2NvbXBsZXRlVGV4dDogJycsCiAgICAgIGdlb2xvY2F0aW9uOiB7CiAgICAgICAgLyoqCiAgICAgICAgICogR29vZ2xlIEdlb2NvZGVyIE9iamV0CiAgICAgICAgICogQHR5cGUge0dlb2NvZGVyfQogICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNHZW9jb2RlcgogICAgICAgICAqLwogICAgICAgIGdlb2NvZGVyOiBudWxsLAogICAgICAgIC8qKgogICAgICAgICAqIEZpbGxlZCBhZnRlciBnZW9sb2NhdGUgcmVzdWx0CiAgICAgICAgICogQHR5cGUge0Nvb3JkaW5hdGVzfQogICAgICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9Db29yZGluYXRlcwogICAgICAgICAqLwogICAgICAgIGxvYzogbnVsbCwKICAgICAgICAvKioKICAgICAgICAgKiBGaWxsZWQgYWZ0ZXIgZ2VvbG9jYXRlIHJlc3VsdAogICAgICAgICAqIEB0eXBlIHtQb3NpdGlvbn0KICAgICAgICAgKiBAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvUG9zaXRpb24KICAgICAgICAgKi8KICAgICAgICBwb3NpdGlvbjogbnVsbAogICAgICB9CiAgICB9CiAgfSwKICB3YXRjaDogewogICAgZm9ybWF0dGVkQWRkcmVzczogewogICAgICBkZWVwOiB0cnVlLAogICAgICBoYW5kbGVyIChuZXdBZGRyZXNzKSB7CiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVUZXh0ID0gbmV3QWRkcmVzcwogICAgICB9CiAgICB9LAogICAgYXV0b2NvbXBsZXRlVGV4dDogZnVuY3Rpb24gKG5ld1ZhbCwgb2xkVmFsKSB7CiAgICAgIHRoaXMuJGVtaXQoJ2lucHV0Q2hhbmdlJywgeyBuZXdWYWwsIG9sZFZhbCB9LCB0aGlzLmlkKQogICAgfSwKICAgIGNvdW50cnk6IGZ1bmN0aW9uIChuZXdWYWwsIG9sZFZhbCkgewogICAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRDb21wb25lbnRSZXN0cmljdGlvbnMoewogICAgICAgIGNvdW50cnk6IHRoaXMuY291bnRyeSA9PT0gbnVsbCA/IFtdIDogdGhpcy5jb3VudHJ5CiAgICAgIH0pCiAgICB9CiAgfSwKICBjb21wdXRlZDogewogICAgLi4ubWFwR2V0dGVycyh7CiAgICAgIGZvcm1hdHRlZEFkZHJlc3M6ICdyZXR1cm5zL2Zvcm1hdHRlZFNoaXBwaW5nQWRkcmVzcycKICAgIH0pCiAgfSwKICBtb3VudGVkOiBmdW5jdGlvbiAoKSB7CiAgICBjb25zdCBvcHRpb25zID0ge30KICAgIGlmICh0aGlzLnR5cGVzKSB7CiAgICAgIG9wdGlvbnMudHlwZXMgPSBbdGhpcy50eXBlc10KICAgIH0KICAgIGlmICh0aGlzLmNvdW50cnkpIHsKICAgICAgb3B0aW9ucy5jb21wb25lbnRSZXN0cmljdGlvbnMgPSB7CiAgICAgICAgY291bnRyeTogdGhpcy5jb3VudHJ5CiAgICAgIH0KICAgIH0KICAgIHRoaXMuYXV0b2NvbXBsZXRlID0gbmV3IGdvb2dsZS5tYXBzLnBsYWNlcy5BdXRvY29tcGxldGUoCiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRoaXMuaWQpLAogICAgICBvcHRpb25zCiAgICApCiAgICB0aGlzLmF1dG9jb21wbGV0ZS5zZXRGaWVsZHModGhpcy5maWVsZHMpCiAgICB0aGlzLmF1dG9jb21wbGV0ZS5hZGRMaXN0ZW5lcigncGxhY2VfY2hhbmdlZCcsIHRoaXMub25QbGFjZUNoYW5nZWQpCiAgfSwKICBtZXRob2RzOiB7CiAgICAvKioKICAgICAqIFdoZW4gYSBwbGFjZSBjaGFuZ2VkCiAgICAgKi8KICAgIG9uUGxhY2VDaGFuZ2VkICgpIHsKICAgICAgY29uc3QgcGxhY2UgPSB0aGlzLmF1dG9jb21wbGV0ZS5nZXRQbGFjZSgpCiAgICAgIGlmICghcGxhY2UuZ2VvbWV0cnkpIHsKICAgICAgICAvLyBVc2VyIGVudGVyZWQgdGhlIG5hbWUgb2YgYSBQbGFjZSB0aGF0IHdhcyBub3Qgc3VnZ2VzdGVkIGFuZAogICAgICAgIC8vIHByZXNzZWQgdGhlIEVudGVyIGtleSwgb3IgdGhlIFBsYWNlIERldGFpbHMgcmVxdWVzdCBmYWlsZWQuCiAgICAgICAgdGhpcy4kZW1pdCgnbm8tcmVzdWx0cy1mb3VuZCcsIHBsYWNlLCB0aGlzLmlkKQogICAgICAgIHJldHVybgogICAgICB9CiAgICAgIGlmIChwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHMgIT09IHVuZGVmaW5lZCkgewogICAgICAgIC8vIHJldHVybiByZXR1cm5EYXRhIG9iamVjdCBhbmQgUGxhY2VSZXN1bHQgb2JqZWN0CiAgICAgICAgdGhpcy4kZW1pdCgncGxhY2VjaGFuZ2VkJywgdGhpcy5mb3JtYXRSZXN1bHQocGxhY2UpLCBwbGFjZSwgdGhpcy5pZCkKICAgICAgICAvLyB1cGRhdGUgYXV0b2NvbXBsZXRlVGV4dCB0aGVuIGVtaXQgY2hhbmdlIGV2ZW50CiAgICAgICAgdGhpcy5hdXRvY29tcGxldGVUZXh0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkudmFsdWUKICAgICAgICB0aGlzLm9uQ2hhbmdlKCkKICAgICAgfQogICAgfSwKICAgIC8qKgogICAgICogV2hlbiB0aGUgaW5wdXQgZ2V0cyBmb2N1cwogICAgICovCiAgICBvbkZvY3VzICgpIHsKICAgICAgdGhpcy5iaWFzQXV0b2NvbXBsZXRlTG9jYXRpb24oKQogICAgICB0aGlzLiRlbWl0KCdmb2N1cycpCiAgICB9LAogICAgLyoqCiAgICAgKiBXaGVuIHRoZSBpbnB1dCBsb3NlcyBmb2N1cwogICAgICovCiAgICBvbkJsdXIgKCkgewogICAgICB0aGlzLiRlbWl0KCdibHVyJykKICAgIH0sCiAgICAvKioKICAgICAqIFdoZW4gdGhlIGlucHV0IGdvdCBjaGFuZ2VkCiAgICAgKi8KICAgIG9uQ2hhbmdlICgpIHsKICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGhpcy5pZCkudmFsdWUpCiAgICB9LAogICAgLyoqCiAgICAgKiBXaGVuIGEga2V5IGdldHMgcHJlc3NlZAogICAgICogQHBhcmFtICB7RXZlbnR9IGV2ZW50IEEga2V5cHJlc3MgZXZlbnQKICAgICAqLwogICAgb25LZXlQcmVzcyAoZXZlbnQpIHsKICAgICAgdGhpcy4kZW1pdCgna2V5cHJlc3MnLCBldmVudCkKICAgIH0sCiAgICAvKioKICAgICAqIFdoZW4gYSBrZXl1cCBvY2N1cnMKICAgICAqIEBwYXJhbSAge0V2ZW50fSBldmVudCBBIGtleXVwIGV2ZW50CiAgICAgKi8KICAgIG9uS2V5VXAgKGV2ZW50KSB7CiAgICAgIHRoaXMuJGVtaXQoJ2tleXVwJywgZXZlbnQpCiAgICB9LAogICAgLyoqCiAgICAgKiBDbGVhciB0aGUgaW5wdXQKICAgICAqLwogICAgY2xlYXIgKCkgewogICAgICB0aGlzLmF1dG9jb21wbGV0ZVRleHQgPSAnJwogICAgfSwKICAgIC8qKgogICAgICogRm9jdXMgdGhlIGlucHV0CiAgICAgKi8KICAgIGZvY3VzICgpIHsKICAgICAgdGhpcy4kcmVmcy5hdXRvY29tcGxldGUuZm9jdXMoKQogICAgfSwKICAgIC8qKgogICAgICogQmx1ciB0aGUgaW5wdXQKICAgICAqLwogICAgYmx1ciAoKSB7CiAgICAgIHRoaXMuJHJlZnMuYXV0b2NvbXBsZXRlLmJsdXIoKQogICAgfSwKICAgIC8qKgogICAgICogVXBkYXRlIHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQKICAgICAqIEBwYXJhbSAge1N0cmluZ30gdmFsdWUKICAgICAqLwogICAgdXBkYXRlICh2YWx1ZSkgewogICAgICB0aGlzLmF1dG9jb21wbGV0ZVRleHQgPSB2YWx1ZQogICAgfSwKICAgIC8qKgogICAgICogVXBkYXRlIHRoZSBjb29yZGluYXRlcyBvZiB0aGUgaW5wdXQKICAgICAqIEBwYXJhbSAge0Nvb3JkaW5hdGVzfSB2YWx1ZQogICAgICovCiAgICB1cGRhdGVDb29yZGluYXRlcyAodmFsdWUpIHsKICAgICAgaWYgKCF2YWx1ZSAmJiAhKHZhbHVlLmxhdCB8fCB2YWx1ZS5sbmcpKSByZXR1cm4KICAgICAgaWYgKCF0aGlzLmdlb2xvY2F0aW9uLmdlb2NvZGVyKSB7CiAgICAgICAgdGhpcy5nZW9sb2NhdGlvbi5nZW9jb2RlciA9IG5ldyBnb29nbGUubWFwcy5HZW9jb2RlcigpCiAgICAgIH0KICAgICAgdGhpcy5nZW9sb2NhdGlvbi5nZW9jb2Rlci5nZW9jb2RlKAogICAgICAgIHsgbG9jYXRpb246IHZhbHVlIH0sCiAgICAgICAgKHJlc3VsdHMsIHN0YXR1cykgPT4gewogICAgICAgICAgaWYgKHN0YXR1cyA9PT0gJ09LJykgewogICAgICAgICAgICByZXN1bHRzID0gdGhpcy5maWx0ZXJHZW9jb2RlUmVzdWx0VHlwZXMocmVzdWx0cykKICAgICAgICAgICAgaWYgKHJlc3VsdHNbMF0pIHsKICAgICAgICAgICAgICB0aGlzLiRlbWl0KAogICAgICAgICAgICAgICAgJ3BsYWNlY2hhbmdlZCcsCiAgICAgICAgICAgICAgICB0aGlzLmZvcm1hdFJlc3VsdChyZXN1bHRzWzBdKSwKICAgICAgICAgICAgICAgIHJlc3VsdHNbMF0sCiAgICAgICAgICAgICAgICB0aGlzLmlkCiAgICAgICAgICAgICAgKQogICAgICAgICAgICAgIHRoaXMudXBkYXRlKHJlc3VsdHNbMF0uZm9ybWF0dGVkX2FkZHJlc3MpCiAgICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgICAgdGhpcy4kZW1pdCgnZXJyb3InLCAnbm8gcmVzdWx0IGZvciBwcm92aWRlZCBjb29yZGluYXRlcycpCiAgICAgICAgICAgIH0KICAgICAgICAgIH0gZWxzZSB7CiAgICAgICAgICAgIHRoaXMuJGVtaXQoJ2Vycm9yJywgJ2Vycm9yIGdldHRpbmcgYWRkcmVzcyBmcm9tIGNvb3JkcycpCiAgICAgICAgICB9CiAgICAgICAgfQogICAgICApCiAgICB9LAogICAgLyoqCiAgICAgKiBVcGRhdGUgbG9jYXRpb24gYmFzZWQgb24gbmF2aWdhdG9yIGdlb2xvY2F0aW9uCiAgICAgKi8KICAgIGdlb2xvY2F0ZSAoKSB7CiAgICAgIHRoaXMudXBkYXRlR2VvbG9jYXRpb24oKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikgPT4gewogICAgICAgIHRoaXMudXBkYXRlQ29vcmRpbmF0ZXMoZ2VvbG9jYXRpb24pCiAgICAgIH0pCiAgICB9LAogICAgLyoqCiAgICAgKiBVcGRhdGUgaW50ZXJuYWwgbG9jYXRpb24gZnJvbSBuYXZpZ2F0b3IgZ2VvbG9jYXRpb24KICAgICAqIEBwYXJhbSAge0Z1bmN0aW9ufSAoZ2VvbG9jYXRpb24sIHBvc2l0aW9uKQogICAgICovCiAgICB1cGRhdGVHZW9sb2NhdGlvbiAoY2FsbGJhY2sgPSBudWxsKSB7CiAgICAgIGlmIChuYXZpZ2F0b3IuZ2VvbG9jYXRpb24pIHsKICAgICAgICBjb25zdCBvcHRpb25zID0ge30KICAgICAgICBpZiAodGhpcy5nZW9sb2NhdGlvbk9wdGlvbnMpIHsKICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0aW9ucywgdGhpcy5nZW9sb2NhdGlvbk9wdGlvbnMpCiAgICAgICAgfQogICAgICAgIG5hdmlnYXRvci5nZW9sb2NhdGlvbi5nZXRDdXJyZW50UG9zaXRpb24oCiAgICAgICAgICAocG9zaXRpb24pID0+IHsKICAgICAgICAgICAgY29uc3QgZ2VvbG9jYXRpb24gPSB7CiAgICAgICAgICAgICAgbGF0OiBwb3NpdGlvbi5jb29yZHMubGF0aXR1ZGUsCiAgICAgICAgICAgICAgbG5nOiBwb3NpdGlvbi5jb29yZHMubG9uZ2l0dWRlCiAgICAgICAgICAgIH0KICAgICAgICAgICAgdGhpcy5nZW9sb2NhdGlvbi5sb2MgPSBnZW9sb2NhdGlvbgogICAgICAgICAgICB0aGlzLmdlb2xvY2F0aW9uLnBvc2l0aW9uID0gcG9zaXRpb24KICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhnZW9sb2NhdGlvbiwgcG9zaXRpb24pCiAgICAgICAgICB9LAogICAgICAgICAgKGVycikgPT4gewogICAgICAgICAgICB0aGlzLiRlbWl0KCdlcnJvcicsICdDYW5ub3QgZ2V0IENvb3JkaW5hdGVzIGZyb20gbmF2aWdhdG9yJywgZXJyKQogICAgICAgICAgfSwKICAgICAgICAgIG9wdGlvbnMKICAgICAgICApCiAgICAgIH0KICAgIH0sCiAgICAvLyBCaWFzIHRoZSBhdXRvY29tcGxldGUgb2JqZWN0IHRvIHRoZSB1c2VyJ3MgZ2VvZ3JhcGhpY2FsIGxvY2F0aW9uLAogICAgLy8gYXMgc3VwcGxpZWQgYnkgdGhlIGJyb3dzZXIncyAnbmF2aWdhdG9yLmdlb2xvY2F0aW9uJyBvYmplY3QuCiAgICBiaWFzQXV0b2NvbXBsZXRlTG9jYXRpb24gKCkgewogICAgICBpZiAodGhpcy5lbmFibGVHZW9sb2NhdGlvbikgewogICAgICAgIHRoaXMudXBkYXRlR2VvbG9jYXRpb24oKGdlb2xvY2F0aW9uLCBwb3NpdGlvbikgPT4gewogICAgICAgICAgY29uc3QgY2lyY2xlID0gbmV3IGdvb2dsZS5tYXBzLkNpcmNsZSh7CiAgICAgICAgICAgIGNlbnRlcjogZ2VvbG9jYXRpb24sCiAgICAgICAgICAgIHJhZGl1czogcG9zaXRpb24uY29vcmRzLmFjY3VyYWN5CiAgICAgICAgICB9KQogICAgICAgICAgdGhpcy5hdXRvY29tcGxldGUuc2V0Qm91bmRzKGNpcmNsZS5nZXRCb3VuZHMoKSkKICAgICAgICB9KQogICAgICB9CiAgICB9LAogICAgLyoqCiAgICAgKiBGb3JtYXQgcmVzdWx0IGZyb20gR2VvIGdvb2dsZSBBUElzCiAgICAgKiBAcGFyYW0gcGxhY2UKICAgICAqIEByZXR1cm5zIHt7Zm9ybWF0dGVkIG91dHB1dH19CiAgICAgKi8KICAgIGZvcm1hdFJlc3VsdCAocGxhY2UpIHsKICAgICAgY29uc3QgcmV0dXJuRGF0YSA9IHt9CiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzLmxlbmd0aDsgaSsrKSB7CiAgICAgICAgY29uc3QgYWRkcmVzc1R5cGUgPSBwbGFjZS5hZGRyZXNzX2NvbXBvbmVudHNbaV0udHlwZXNbMF0KICAgICAgICBpZiAoQUREUkVTU19DT01QT05FTlRTW2FkZHJlc3NUeXBlXSkgewogICAgICAgICAgY29uc3QgdmFsID0KICAgICAgICAgICAgcGxhY2UuYWRkcmVzc19jb21wb25lbnRzW2ldW0FERFJFU1NfQ09NUE9ORU5UU1thZGRyZXNzVHlwZV1dCiAgICAgICAgICByZXR1cm5EYXRhW2FkZHJlc3NUeXBlXSA9IHZhbAogICAgICAgIH0KICAgICAgfQogICAgICByZXR1cm5EYXRhLmxhdGl0dWRlID0gcGxhY2UuZ2VvbWV0cnkubG9jYXRpb24ubGF0KCkKICAgICAgcmV0dXJuRGF0YS5sb25naXR1ZGUgPSBwbGFjZS5nZW9tZXRyeS5sb2NhdGlvbi5sbmcoKQogICAgICByZXR1cm4gcmV0dXJuRGF0YQogICAgfSwKICAgIC8qKgogICAgICogRXh0cmFjdCBjb25maWd1cmVkIHR5cGVzIG91dCBvZiByYXcgcmVzdWx0IGFzCiAgICAgKiBHZW9jb2RlIEFQSSBkb2VzIG5vdCBhbGxvdyB0byBkbyBpdAogICAgICogQHBhcmFtIHJlc3VsdHMKICAgICAqIEByZXR1cm5zIHtHZW9jb2RlclJlc3VsdH0KICAgICAqIEBsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL21hcHMvZG9jdW1lbnRhdGlvbi9qYXZhc2NyaXB0L3JlZmVyZW5jZSNHZW9jb2RlclJlc3VsdAogICAgICovCiAgICBmaWx0ZXJHZW9jb2RlUmVzdWx0VHlwZXMgKHJlc3VsdHMpIHsKICAgICAgaWYgKCFyZXN1bHRzIHx8ICF0aGlzLnR5cGVzKSByZXR1cm4gcmVzdWx0cwogICAgICBjb25zdCBvdXRwdXQgPSBbXQogICAgICBsZXQgdHlwZXMgPSBbdGhpcy50eXBlc10KICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCcoY2l0aWVzKScpKSB0eXBlcyA9IHR5cGVzLmNvbmNhdChDSVRJRVNfVFlQRSkKICAgICAgaWYgKHR5cGVzLmluY2x1ZGVzKCcocmVnaW9ucyknKSkgdHlwZXMgPSB0eXBlcy5jb25jYXQoUkVHSU9OU19UWVBFKQogICAgICBmb3IgKGNvbnN0IHIgb2YgcmVzdWx0cykgewogICAgICAgIGZvciAoY29uc3QgdCBvZiByLnR5cGVzKSB7CiAgICAgICAgICBpZiAodHlwZXMuaW5jbHVkZXModCkpIHsKICAgICAgICAgICAgb3V0cHV0LnB1c2gocikKICAgICAgICAgICAgYnJlYWsKICAgICAgICAgIH0KICAgICAgICB9CiAgICAgIH0KICAgICAgcmV0dXJuIG91dHB1dAogICAgfQogIH0KfQo="},{"version":3,"sources":["OPlacesAutoComplete.vue"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"OPlacesAutoComplete.vue","sourceRoot":"src/components/atoms","sourcesContent":["// Code based on from https://github.com/olefirenko/vue-google-autocomplete\n\n<template>\n  <o-text-field\n    ref=\"autocomplete\"\n    type=\"text\"\n    :class=\"classname\"\n    :id=\"id\"\n    :placeholder=\"placeholder\"\n    :disabled=\"disabled\"\n    v-model=\"autocompleteText\"\n    @focus=\"onFocus()\"\n    @blur=\"onBlur()\"\n    @change=\"onChange\"\n    @keypress=\"onKeyPress\"\n    @keyup=\"onKeyUp\"\n    @onChange=\"onChange\"\n    v-bind=\"{...$props, ...$attrs}\"\n  />\n</template>\n\n<script>\nimport OTextField from '@/components/molecules/OTextField.vue'\nimport { mapGetters } from 'vuex'\n/* global google */\nconst ADDRESS_COMPONENTS = {\n  subpremise: 'short_name',\n  street_number: 'short_name',\n  route: 'long_name',\n  locality: 'long_name',\n  administrative_area_level_1: 'short_name',\n  administrative_area_level_2: 'long_name',\n  country: 'long_name',\n  postal_code: 'short_name'\n}\nconst CITIES_TYPE = ['locality', 'administrative_area_level_3']\nconst REGIONS_TYPE = [\n  'locality',\n  'sublocality',\n  'postal_code',\n  'country',\n  'administrative_area_level_1',\n  'administrative_area_level_2'\n]\n/*\n      By default, we're only including basic place data because requesting these\n      fields place data is not additionally charged by Google. Please refer to:\n      https://developers.google.com/maps/billing/understanding-cost-of-use#basic-data\n    */\nconst BASIC_DATA_FIELDS = [\n  'address_components',\n  'adr_address',\n  'alt_id',\n  'formatted_address',\n  'geometry',\n  'icon',\n  'id',\n  'name',\n  'business_status',\n  'photo',\n  'place_id',\n  'scope',\n  'type',\n  'url',\n  'vicinity'\n]\nexport default {\n  components: { OTextField },\n  name: 'VueGoogleAutocomplete',\n  props: {\n    id: {\n      type: String,\n      required: true\n    },\n    classname: {\n      type: String,\n      required: false,\n      default: ''\n    },\n    placeholder: {\n      type: String,\n      default: 'Start typing'\n    },\n    disabled: {\n      type: Boolean,\n      default: false\n    },\n    types: {\n      type: String,\n      default: 'address'\n    },\n    fields: {\n      type: Array,\n      default: function () {\n        return BASIC_DATA_FIELDS\n      }\n    },\n    country: {\n      type: [String, Array],\n      default: null\n    },\n    enableGeolocation: {\n      type: Boolean,\n      default: false\n    },\n    geolocationOptions: {\n      type: Object,\n      default: null\n    }\n  },\n  data () {\n    return {\n      /**\n       * The Autocomplete object.\n       *\n       * @type {Autocomplete}\n       * @link https://developers.google.com/maps/documentation/javascript/reference#Autocomplete\n       */\n      autocomplete: null,\n      /**\n       * Autocomplete input text\n       * @type {String}\n       */\n      autocompleteText: '',\n      geolocation: {\n        /**\n         * Google Geocoder Objet\n         * @type {Geocoder}\n         * @link https://developers.google.com/maps/documentation/javascript/reference#Geocoder\n         */\n        geocoder: null,\n        /**\n         * Filled after geolocate result\n         * @type {Coordinates}\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/Coordinates\n         */\n        loc: null,\n        /**\n         * Filled after geolocate result\n         * @type {Position}\n         * @link https://developer.mozilla.org/en-US/docs/Web/API/Position\n         */\n        position: null\n      }\n    }\n  },\n  watch: {\n    formattedAddress: {\n      deep: true,\n      handler (newAddress) {\n        this.autocompleteText = newAddress\n      }\n    },\n    autocompleteText: function (newVal, oldVal) {\n      this.$emit('inputChange', { newVal, oldVal }, this.id)\n    },\n    country: function (newVal, oldVal) {\n      this.autocomplete.setComponentRestrictions({\n        country: this.country === null ? [] : this.country\n      })\n    }\n  },\n  computed: {\n    ...mapGetters({\n      formattedAddress: 'returns/formattedShippingAddress'\n    })\n  },\n  mounted: function () {\n    const options = {}\n    if (this.types) {\n      options.types = [this.types]\n    }\n    if (this.country) {\n      options.componentRestrictions = {\n        country: this.country\n      }\n    }\n    this.autocomplete = new google.maps.places.Autocomplete(\n      document.getElementById(this.id),\n      options\n    )\n    this.autocomplete.setFields(this.fields)\n    this.autocomplete.addListener('place_changed', this.onPlaceChanged)\n  },\n  methods: {\n    /**\n     * When a place changed\n     */\n    onPlaceChanged () {\n      const place = this.autocomplete.getPlace()\n      if (!place.geometry) {\n        // User entered the name of a Place that was not suggested and\n        // pressed the Enter key, or the Place Details request failed.\n        this.$emit('no-results-found', place, this.id)\n        return\n      }\n      if (place.address_components !== undefined) {\n        // return returnData object and PlaceResult object\n        this.$emit('placechanged', this.formatResult(place), place, this.id)\n        // update autocompleteText then emit change event\n        this.autocompleteText = document.getElementById(this.id).value\n        this.onChange()\n      }\n    },\n    /**\n     * When the input gets focus\n     */\n    onFocus () {\n      this.biasAutocompleteLocation()\n      this.$emit('focus')\n    },\n    /**\n     * When the input loses focus\n     */\n    onBlur () {\n      this.$emit('blur')\n    },\n    /**\n     * When the input got changed\n     */\n    onChange () {\n      this.$emit('change', document.getElementById(this.id).value)\n    },\n    /**\n     * When a key gets pressed\n     * @param  {Event} event A keypress event\n     */\n    onKeyPress (event) {\n      this.$emit('keypress', event)\n    },\n    /**\n     * When a keyup occurs\n     * @param  {Event} event A keyup event\n     */\n    onKeyUp (event) {\n      this.$emit('keyup', event)\n    },\n    /**\n     * Clear the input\n     */\n    clear () {\n      this.autocompleteText = ''\n    },\n    /**\n     * Focus the input\n     */\n    focus () {\n      this.$refs.autocomplete.focus()\n    },\n    /**\n     * Blur the input\n     */\n    blur () {\n      this.$refs.autocomplete.blur()\n    },\n    /**\n     * Update the value of the input\n     * @param  {String} value\n     */\n    update (value) {\n      this.autocompleteText = value\n    },\n    /**\n     * Update the coordinates of the input\n     * @param  {Coordinates} value\n     */\n    updateCoordinates (value) {\n      if (!value && !(value.lat || value.lng)) return\n      if (!this.geolocation.geocoder) {\n        this.geolocation.geocoder = new google.maps.Geocoder()\n      }\n      this.geolocation.geocoder.geocode(\n        { location: value },\n        (results, status) => {\n          if (status === 'OK') {\n            results = this.filterGeocodeResultTypes(results)\n            if (results[0]) {\n              this.$emit(\n                'placechanged',\n                this.formatResult(results[0]),\n                results[0],\n                this.id\n              )\n              this.update(results[0].formatted_address)\n            } else {\n              this.$emit('error', 'no result for provided coordinates')\n            }\n          } else {\n            this.$emit('error', 'error getting address from coords')\n          }\n        }\n      )\n    },\n    /**\n     * Update location based on navigator geolocation\n     */\n    geolocate () {\n      this.updateGeolocation((geolocation, position) => {\n        this.updateCoordinates(geolocation)\n      })\n    },\n    /**\n     * Update internal location from navigator geolocation\n     * @param  {Function} (geolocation, position)\n     */\n    updateGeolocation (callback = null) {\n      if (navigator.geolocation) {\n        const options = {}\n        if (this.geolocationOptions) {\n          Object.assign(options, this.geolocationOptions)\n        }\n        navigator.geolocation.getCurrentPosition(\n          (position) => {\n            const geolocation = {\n              lat: position.coords.latitude,\n              lng: position.coords.longitude\n            }\n            this.geolocation.loc = geolocation\n            this.geolocation.position = position\n            if (callback) callback(geolocation, position)\n          },\n          (err) => {\n            this.$emit('error', 'Cannot get Coordinates from navigator', err)\n          },\n          options\n        )\n      }\n    },\n    // Bias the autocomplete object to the user's geographical location,\n    // as supplied by the browser's 'navigator.geolocation' object.\n    biasAutocompleteLocation () {\n      if (this.enableGeolocation) {\n        this.updateGeolocation((geolocation, position) => {\n          const circle = new google.maps.Circle({\n            center: geolocation,\n            radius: position.coords.accuracy\n          })\n          this.autocomplete.setBounds(circle.getBounds())\n        })\n      }\n    },\n    /**\n     * Format result from Geo google APIs\n     * @param place\n     * @returns {{formatted output}}\n     */\n    formatResult (place) {\n      const returnData = {}\n      for (let i = 0; i < place.address_components.length; i++) {\n        const addressType = place.address_components[i].types[0]\n        if (ADDRESS_COMPONENTS[addressType]) {\n          const val =\n            place.address_components[i][ADDRESS_COMPONENTS[addressType]]\n          returnData[addressType] = val\n        }\n      }\n      returnData.latitude = place.geometry.location.lat()\n      returnData.longitude = place.geometry.location.lng()\n      return returnData\n    },\n    /**\n     * Extract configured types out of raw result as\n     * Geocode API does not allow to do it\n     * @param results\n     * @returns {GeocoderResult}\n     * @link https://developers.google.com/maps/documentation/javascript/reference#GeocoderResult\n     */\n    filterGeocodeResultTypes (results) {\n      if (!results || !this.types) return results\n      const output = []\n      let types = [this.types]\n      if (types.includes('(cities)')) types = types.concat(CITIES_TYPE)\n      if (types.includes('(regions)')) types = types.concat(REGIONS_TYPE)\n      for (const r of results) {\n        for (const t of r.types) {\n          if (types.includes(t)) {\n            output.push(r)\n            break\n          }\n        }\n      }\n      return output\n    }\n  }\n}\n</script>\n"]}]}